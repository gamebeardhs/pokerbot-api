<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTO Database Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2d5a27 0%, #4a8e3b 100%);
            border-radius: 10px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .metric-card {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4a8e3b;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a8e3b;
            margin-bottom: 5px;
        }
        .metric-label {
            color: #cccccc;
            font-size: 14px;
        }
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .test-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .test-button {
            background: #4a8e3b;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .test-button:hover {
            background: #3a7e2b;
        }
        .test-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .results-area {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-healthy { background-color: #4a8e3b; }
        .status-warning { background-color: #f39c12; }
        .status-error { background-color: #e74c3c; }
        .performance-charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .chart-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <h1>üéØ Hybrid GTO Database Dashboard</h1>
        <p>Real-time monitoring and testing of the poker advisory system</p>
    </div>

    <div class="metrics-grid" id="metricsGrid">
        <!-- Metrics will be populated by JavaScript -->
    </div>

    <div class="test-section">
        <h3>üß™ Performance Testing</h3>
        <div class="test-controls">
            <button class="test-button" onclick="runSingleTest()">Single Query Test</button>
            <button class="test-button" onclick="runBenchmark()">Benchmark Test (10 queries)</button>
            <button class="test-button" onclick="runStressTest()">Stress Test (100 queries)</button>
            <button class="test-button" onclick="testDatabaseScaling()">Database Scaling Test</button>
            <button class="test-button" onclick="clearResults()">Clear Results</button>
        </div>
        <div class="results-area" id="testResults">Ready to run tests...</div>
    </div>

    <div class="performance-charts">
        <div class="chart-container">
            <h4>üìä Query Response Times</h4>
            <canvas id="responseTimeChart" width="400" height="200"></canvas>
        </div>
        <div class="chart-container">
            <h4>üìà Decision Distribution</h4>
            <canvas id="decisionChart" width="400" height="200"></canvas>
        </div>
    </div>

    <script>
        let testResults = [];
        let isTestRunning = false;

        // Update metrics every 5 seconds
        setInterval(updateMetrics, 5000);
        updateMetrics(); // Initial load

        async function updateMetrics() {
            try {
                const response = await fetch('/database/database-stats');
                const stats = await response.json();
                
                const metricsGrid = document.getElementById('metricsGrid');
                metricsGrid.innerHTML = `
                    <div class="metric-card">
                        <div class="status-indicator ${getStatusClass(stats.status)}"></div>
                        <div class="metric-value">${stats.status.toUpperCase()}</div>
                        <div class="metric-label">Database Status</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${stats.total_situations.toLocaleString()}</div>
                        <div class="metric-label">GTO Situations</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${stats.hnsw_index_size.toLocaleString()}</div>
                        <div class="metric-label">HNSW Index Size</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${stats.average_query_time_ms.toFixed(1)}ms</div>
                        <div class="metric-label">Avg Query Time</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${stats.database_size_mb.toFixed(1)}MB</div>
                        <div class="metric-label">Database Size</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${Math.round(stats.total_situations / 22967 * 100)}%</div>
                        <div class="metric-label">Coverage Estimate</div>
                    </div>
                `;
            } catch (error) {
                console.error('Failed to update metrics:', error);
            }
        }

        function getStatusClass(status) {
            switch (status.toLowerCase()) {
                case 'healthy': return 'status-healthy';
                case 'warning': return 'status-warning';
                default: return 'status-error';
            }
        }

        async function runSingleTest() {
            if (isTestRunning) return;
            setTestRunning(true);

            const testSituation = {
                hole_cards: ["As", "Kh"],
                board_cards: ["Qd", "Jc", "9s"],
                position: "BTN",
                pot_size: 15.0,
                bet_to_call: 5.0,
                stack_size: 100.0,
                num_players: 3,
                betting_round: "flop"
            };

            appendResult("üéØ Running single test query...");
            
            try {
                const start = performance.now();
                const response = await fetch('/database/instant-gto', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(testSituation)
                });
                const responseTime = performance.now() - start;
                
                if (response.ok) {
                    const result = await response.json();
                    appendResult(`‚úÖ Success in ${responseTime.toFixed(1)}ms`);
                    appendResult(`   Decision: ${result.recommendation?.decision || 'unknown'}`);
                    appendResult(`   Method: ${result.method || 'unknown'}`);
                    appendResult(`   Confidence: ${result.recommendation?.confidence || 0}`);
                } else {
                    appendResult(`‚ùå Failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                appendResult(`‚ùå Error: ${error.message}`);
            }
            
            setTestRunning(false);
        }

        async function runBenchmark() {
            if (isTestRunning) return;
            setTestRunning(true);

            const testCases = [
                { hole_cards: ["As", "Ad"], position: "UTG", pot_size: 3, bet_to_call: 2, stack_size: 100, num_players: 9, betting_round: "preflop" },
                { hole_cards: ["Kh", "Kd"], position: "BTN", pot_size: 7, bet_to_call: 0, stack_size: 150, num_players: 6, betting_round: "preflop" },
                { hole_cards: ["Ah", "Kh"], board_cards: ["Qh", "Jh", "2c"], position: "CO", pot_size: 20, bet_to_call: 8, stack_size: 200, num_players: 3, betting_round: "flop" },
                { hole_cards: ["9d", "9c"], board_cards: ["As", "Kh", "Qd"], position: "SB", pot_size: 45, bet_to_call: 15, stack_size: 180, num_players: 2, betting_round: "flop" },
                { hole_cards: ["Td", "Jd"], board_cards: ["9h", "8s", "2c", "7d"], position: "BB", pot_size: 80, bet_to_call: 25, stack_size: 120, num_players: 2, betting_round: "turn" }
            ];

            appendResult("üìä Running benchmark test (10 queries)...");
            
            let successCount = 0;
            let totalTime = 0;
            const responseTimes = [];

            for (let i = 0; i < 10; i++) {
                const testCase = testCases[i % testCases.length];
                
                try {
                    const start = performance.now();
                    const response = await fetch('/database/instant-gto', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testCase)
                    });
                    const responseTime = performance.now() - start;
                    
                    if (response.ok) {
                        successCount++;
                        totalTime += responseTime;
                        responseTimes.push(responseTime);
                        appendResult(`  Query ${i+1}: ‚úÖ ${responseTime.toFixed(1)}ms`);
                    } else {
                        appendResult(`  Query ${i+1}: ‚ùå ${response.status}`);
                    }
                } catch (error) {
                    appendResult(`  Query ${i+1}: ‚ùå Error`);
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            const avgTime = totalTime / successCount;
            const successRate = (successCount / 10) * 100;
            
            appendResult(`\nüìà Benchmark Results:`);
            appendResult(`   Success Rate: ${successRate}% (${successCount}/10)`);
            appendResult(`   Average Time: ${avgTime.toFixed(1)}ms`);
            appendResult(`   Min/Max: ${Math.min(...responseTimes).toFixed(1)}ms / ${Math.max(...responseTimes).toFixed(1)}ms`);
            appendResult(`   Performance: ${avgTime < 50 ? 'üöÄ Excellent' : avgTime < 100 ? '‚úÖ Good' : '‚ö†Ô∏è Needs optimization'}`);
            
            setTestRunning(false);
        }

        async function runStressTest() {
            if (isTestRunning) return;
            setTestRunning(true);
            
            appendResult("üî• Running stress test (100 concurrent queries)...");
            appendResult("This may take a few minutes...");
            
            const testCase = {
                hole_cards: ["As", "Kh"],
                position: "BTN",
                pot_size: 10,
                bet_to_call: 3,
                stack_size: 100,
                num_players: 6,
                betting_round: "preflop"
            };

            const promises = [];
            const startTime = performance.now();
            
            for (let i = 0; i < 100; i++) {
                promises.push(
                    fetch('/database/instant-gto', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testCase)
                    }).then(response => ({ success: response.ok, status: response.status }))
                    .catch(() => ({ success: false, status: 'error' }))
                );
            }
            
            try {
                const results = await Promise.all(promises);
                const totalTime = performance.now() - startTime;
                const successCount = results.filter(r => r.success).length;
                
                appendResult(`\nüéØ Stress Test Results:`);
                appendResult(`   Total Time: ${totalTime.toFixed(0)}ms`);
                appendResult(`   Success Rate: ${(successCount/100*100).toFixed(1)}% (${successCount}/100)`);
                appendResult(`   Throughput: ${(100/totalTime*1000).toFixed(1)} queries/sec`);
                appendResult(`   System Load: ${successCount > 90 ? 'üöÄ Excellent' : successCount > 70 ? '‚úÖ Good' : '‚ö†Ô∏è High load detected'}`);
                
            } catch (error) {
                appendResult(`‚ùå Stress test failed: ${error.message}`);
            }
            
            setTestRunning(false);
        }

        async function testDatabaseScaling() {
            if (isTestRunning) return;
            setTestRunning(true);
            
            appendResult("üìà Testing database scaling capabilities...");
            
            try {
                const response = await fetch('/database/database-stats');
                const stats = await response.json();
                
                appendResult(`\nüìä Current Database Analysis:`);
                appendResult(`   Situations: ${stats.total_situations.toLocaleString()}`);
                appendResult(`   Index Size: ${stats.hnsw_index_size.toLocaleString()}`);
                appendResult(`   Storage: ${stats.database_size_mb.toFixed(1)}MB`);
                appendResult(`   Query Time: ${stats.average_query_time_ms.toFixed(1)}ms`);
                
                // Scaling recommendations based on current size
                const current = stats.total_situations;
                if (current < 10000) {
                    appendResult(`\nüéØ Scaling Recommendation: MVP Coverage`);
                    appendResult(`   Target: 10,000 situations (current: ${current.toLocaleString()})`);
                    appendResult(`   Coverage: Will increase from 0.4% to 4.3%`);
                    appendResult(`   Storage: ~30MB total`);
                } else if (current < 50000) {
                    appendResult(`\nüöÄ Scaling Recommendation: Production Ready`);
                    appendResult(`   Target: 50,000 situations (current: ${current.toLocaleString()})`);
                    appendResult(`   Coverage: Will increase to 21.7%`);
                    appendResult(`   Storage: ~150MB total`);
                } else {
                    appendResult(`\nüèÜ System Status: Professional Grade`);
                    appendResult(`   Current size sufficient for production use`);
                    appendResult(`   Consider optimizing query patterns`);
                }
                
                appendResult(`\n‚ö° Performance Targets:`);
                appendResult(`   Query Time: <50ms avg (current: ${stats.average_query_time_ms.toFixed(1)}ms)`);
                appendResult(`   Success Rate: >90% (test to verify)`);
                appendResult(`   Throughput: >20 queries/sec`);
                
            } catch (error) {
                appendResult(`‚ùå Scaling analysis failed: ${error.message}`);
            }
            
            setTestRunning(false);
        }

        function appendResult(text) {
            const resultsArea = document.getElementById('testResults');
            resultsArea.innerHTML += text + '\n';
            resultsArea.scrollTop = resultsArea.scrollHeight;
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = 'Results cleared...\n';
        }

        function setTestRunning(running) {
            isTestRunning = running;
            document.querySelectorAll('.test-button').forEach(btn => {
                btn.disabled = running;
            });
        }
    </script>
</body>
</html>